{"posts":[{"title":"Vulkan(1)：环境配置","text":"Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2025/12/04/Vulkan-1-%EF%BC%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2025/12/04/hello-world/"},{"title":"Vulkan总览","text":"Vulkan总览图像视图要绘制从交换链获取的图像，通常将其包装到 vk::ImageView 和 vk::Framebuffer 中。图像视图引用要使用的图像的特定部分，而帧缓冲区引用要用于color、depth和stencil目标的图像视图。因为交换链中可能有很多不同的图像，所以应预先为每个图像创建一个图像视图和帧缓冲区，并在绘制时选择正确的图像。 动态渲染有了动态渲染（Vulkan 1.3 中引入），就完全不需要创建 vk::Framebuffer 了。动态渲染消除了对预定义render passes和framebuffers的需求，允许我们在命令录制期间直接指定rendering attachments。这使得 API 更加简单，因为我们可以动态定义渲染目标，而无需担心管理帧缓冲区的开销。 使用动态渲染，我们不再需要预定义 vk::RenderPass 或 vk::Framebuffer。相反，我们可以在命令录制开始时指定rendering attachments，使用 vk::beginRendering 和类似 vk::RenderingInfo 的结构体来动态提供所有必要的附件信息。 渲染管线Vulkan 中的图形管线是通过创建 VkPipeline 对象来设置的。它描述了显卡的可配置状态，例如视口大小和深度缓冲区操作，以及正在使用的 vk::ShaderModule 对象的可编程状态。vk::ShaderModule 对象由着色器字节码创建。驱动程序还需要知道渲染管线中将要使用哪些渲染目标，我们通过引用渲染通道来指定这些目标。 与现有 API 相比，Vulkan 最显著的特点之一是，几乎所有图形管线的配置都需要预先设置。这意味着，如果你想切换到不同的着色器或稍微改变顶点布局，那么你需要完全重新创建图形管线。这意味着您需要预先创建许多 vk::Pipeline 对象，以满足渲染操作所需的各种不同组合。只有一些基本配置，例如视口大小和清除颜色，可以动态更改。所有状态也都需要明确描述；例如，没有默认的颜色混合状态。 由于你执行的是相当于提前编译而不是即时编译的操作，因此驱动程序有更多的优化机会。运行时性能也更加可预测，因为诸如切换到不同图形管线之类的大规模状态变更都被明确地显式声明了。 命令池和命令缓冲区如前所述，我们在 Vulkan 中想要执行的许多操作（例如绘图操作）需要提交到队列中。这些操作需要先记录到 vk::CommandBuffer 中，然后才能提交。这些command buffers是从与特定queue family关联的 vk::CommandPool 中分配的。传统上，要绘制一个简单的三角形，我们需要记录一个包含以下操作的command buffer： Begin the render pass Bind the graphics pipeline Draw three vertices End the render pass 然而，使用dynamic rendering时，情况就不同了。我们不再需要“beginning”和“ending” render pass，而是在开始渲染时使用 vk::BeginRendering 直接定义渲染附件。","link":"/2025/12/09/Vulkan%E6%80%BB%E8%A7%88/"}],"tags":[],"categories":[{"name":"Graphics","slug":"Graphics","link":"/categories/Graphics/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"Vulkan","slug":"Graphics/Vulkan","link":"/categories/Graphics/Vulkan/"}],"pages":[]}